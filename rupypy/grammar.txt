# compstmt: line* statement? [LINE_END]?;
# unfortunately you need to inline this anywhere you want it because ebnf parse
# doesn't support epsilon productions.

main: line* statement? [LINE_END]? [EOF];

# XXX: LINE_END includes ';' which isn't valid for here, split LINE_END into
# two tokens and then have a non-terminal here for their union.
array_trailer: LINE_END |
               COMMA;

line: statement? [LINE_END];

# operator expressions, ordered by precedence
# Operator     		Description
# [ ] [ ]=		Element reference, element set
# **			Exponentiation
# ! ~ + -		Not, complement, unary plus and minus
# * / %			Multiply, divide, and modulo
# + -          	      	Plus and minus
# >> <<		      	Right and left shift
# &		      	Bitwise `and'
# ^ |		      	Bitwise exclusive `or' and regular `or'
# <= < > >=	      	Comparison operators
# <=> == === != =~ !~ 	Equality and pattern match operators
# &&	     	   	Logical `and'
# ||			Logical `or'
# .. ...		Range (inclusive and exclusive)
# ? :			Ternary if-then-else
# = %= { /= -= += |= &= >>= <<= *= &&= ||= **=	Assignment
# defined?	     	Check if symbol defined
# not			`literal_not`
# or and		`literal_bool`
# if unless while until	`inline_*`
# begin/end	  	Block expression

statement: inline_if |
           inline_unless |
           inline_until |
           inline_while |
           inline_rescue |
           <real_statement>;

inline_if: real_statement IF_INLINE expr;

inline_unless: real_statement UNLESS_INLINE expr;

inline_until: real_statement UNTIL_INLINE expr;

inline_while: real_statement WHILE_INLINE expr;

inline_rescue: real_statement RESCUE_INLINE expr;

real_statement: return_expr | alias | expr;

return_expr: RETURN expr_splats?;

alias: ALIAS method_name method_name;

expr_splats: expr_splat [COMMA] >expr_splats< | expr_splat;
expr_splat: <expr> | <splat>;

expr: <literal_bool>;

literal_bool: contained_expr literal_bool_oper literal_bool | <contained_expr>;
literal_bool_oper: <OR_LITERAL> | <AND_LITERAL>;

contained_expr: literal_not | assignment | yield | arg;
literal_not: NOT_LITERAL contained_expr;

assignment_oper: <EQ> | <PLUS_EQUAL> | <MINUS_EQUAL> | <MUL_EQUAL> |
                 <DIV_EQUAL> | <MODULO_EQUAL> | <OR_EQUAL> | <AND_EQUAL> |
                 <PIPE_EQUAL> | <AMP_EQUAL>;

assignment: assign_lhs assignment_oper expr_splats;
assign_lhs: <assign_target_splat> | <assign_target>;
assign_target_splat: send [COMMA] >assign_target_splat< |
                     splat [COMMA] >assign_target< |
                     splat;
assign_target: send [COMMA] >assign_target< | send;

yield: YIELD [LPAREN] args? [RPAREN] |
       YIELD args?;

arg: ternary;

ternary: range QUESTION ternary COLON ternary | <range>;

range_oper: <DOTDOT> | <DOTDOTDOT>;
match_oper: <EQUAL_TILDE> | <EXCLAMATION_TILDE>;
bool_oper: <OR> | <AND> | <CARET>;
cmp_oper: <EQEQ> | <EQEQEQ> | <NE> | <LT> | <LE> | <GT> | <GE> | <LEGT>;
shift_oper: <LSHIFT> | <RSHIFT>;
add_oper: <PLUS> | <MINUS>;
mul_oper: <DIV> | <MODULO> | <MUL>;
unary_oper: <UNARY_MINUS> | <TILDE> | <EXCLAMATION>;

range: match range_oper range | <match>;
match: bool match_oper match | <bool>;
bool: comparison bool_oper bool | <comparison>;
comparison: or cmp_oper comparison | <or>;
or: and PIPE or | <and>;
and: shiftive AMP and | <shiftive>;
shiftive: additive shift_oper shiftive | <additive>;
additive: multitive add_oper additive | <multitive>;
multitive: unary_op mul_oper multitive | <unary_op>;

unary_op: unary_oper expr | <pow>;

pow: send POW pow | <send>;

send: <do_block> |
      real_send |
      <primary>;

do_block: real_send DO block_args? line* statement? [LINE_END]? END;

block_args: [PIPE] arglist? [PIPE] |
            [OR];

real_send: primary trailers |
           global_paren_send trailers |
           ambigious_binop |
           global_send;

global_method_name: <IDENTIFIER> | <CONSTANT>;

global_send: global_method_name block |
             global_paren_send |
             global_method_name send_args;

global_paren_send: global_method_name [LPAREN] send_args? [RPAREN] block?;

block: [LBRACE] block_args? line* statement? [LINE_END]? [RBRACE];

trailers: trailer >trailers< | trailer;

trailer: subscript | attribute | constant;
attribute_lookup: DOT | COLONCOLON;
attribute: [attribute_lookup] IDENTIFIER [LPAREN] send_args? [RPAREN] block? |
           [attribute_lookup] IDENTIFIER block |
           [attribute_lookup] IDENTIFIER send_args?;
subscript: LSUBSCRIPT args? [RBRACKET];
constant: COLONCOLON CONSTANT;

ambigious_binop: IDENTIFIER UNARY_MINUS arg;

primary: LPAREN expr RPAREN |
         LBRACKET array |
         LBRACE hash |
         IF if elsifs? else? [END] |
         UNLESS if else? [END] |
         WHILE expr do line* statement? [LINE_END]? END |
         UNTIL expr do line* statement? [LINE_END]? END |
         DEF function_name argdecl line* statement? [LINE_END]? rescue* ensure? [END] |
         CLASS LSHIFT arg [LINE_END] line* statement? [LINE_END]? END |
         CLASS CONSTANT (LT arg)? [LINE_END] line* statement? [LINE_END]? END |
         MODULE CONSTANT line* statement? [LINE_END]? END |
         BEGIN line* statement? [LINE_END]? rescue* else? ensure? [END] |
         CASE expr? [LINE_END]? whens else? END |
         UNBOUND_COLONCOLON CONSTANT |
         varname |
         literal;

array: [RBRACKET] |
       args [array_trailer]? [RBRACKET];

hash: [RBRACE] |
      assocs [array_trailer]? [RBRACE];

if: expr [LINE_END]? then line* statement? [LINE_END]?;

then: [LINE_END] |
      THEN |
      [LINE_END] THEN;

do: [LINE_END] |
    DO |
    [LINE_END] DO;

elsifs: elsif >elsifs< | elsif;

elsif: ELSIF expr then line* statement? [LINE_END]?;

else: ELSE line* statement? [LINE_END]?;

rescue: RESCUE exprs? (ARROW varname)? line* statement? [LINE_END]?;

exprs: expr [COMMA] >exprs< | expr;

ensure: ENSURE line* statement? [LINE_END]?;

whens: when >whens< | when;

when: WHEN exprs then line* statement? [LINE_END]?;

function_name: varname [DOT] method_name |
               method_name;

method_name: <IDENTIFIER> | <LEGT> | <EQEQEQ> | <LT> | <GT> | <GE> | <LE> |
             <EQEQ> | <LSHIFT> | <EQUAL_TILDE> | <MINUS>;

argdecl: [LPAREN] arglist? [RPAREN] |
         arglist? [LINE_END];

arglist: argdef [COMMA] >arglist< | argdef;

argdef: IDENTIFIER [EQ] arg |
        UNARY_STAR IDENTIFIER? |
        AMP IDENTIFIER |
        IDENTIFIER;

send_args: args ([COMMA] block_arg)? |
           block_arg;

args: argument [COMMA] >args< | argument;

argument: <assoc> | <arg> | <splat>;

splat: [UNARY_STAR] arg;

block_arg: [AMP] arg;

assocs: assoc [COMMA] >assocs< | assoc;

assoc: contained_expr ARROW contained_expr;

varname: IDENTIFIER | CONSTANT | CLASS_VAR | INSTANCE_VAR | GLOBAL;

literal: NUMBER | symbol | qwords | regexp | shellout | strings | quote;

symbol: [SYMBOL_BEGIN] symbol_contents;

symbol_contents: <varname> | <SSTRING> | <string>;

qwords: [QWORDS_BEGIN] strings [QWORDS_END];

regexp: [REGEXP_BEGIN] string [REGEXP_END];

shellout: [SHELL_BEGIN] string [SHELL_END];

quote: [QUOTE_BEGIN] string [QUOTE_END];

strings: quote >real_strings< | <real_strings>;
real_strings: string >real_strings< | SSTRING >real_strings< | string | SSTRING;

string: [STRING_BEGIN] string_contents* [STRING_END];

string_contents: <STRING_VALUE> |
                 [DSTRING_START] <statement> [DSTRING_END];

