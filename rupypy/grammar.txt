# compstmt: line* statement? [LINE_END]?;
# unfortunately you need to inline this anywhere you want it because ebnf parse
# doesn't support epsilon productions.

main: line* statement? [LINE_END]? [EOF];

line: statement? [LINE_END];

statement: inline_if |
           inline_unless |
           inline_until |
           <real_statement>;

inline_if: real_statement IF_INLINE expr;

inline_unless: real_statement UNLESS_INLINE expr;

inline_until: real_statement UNTIL_INLINE expr;

real_statement: RETURN expr? |
                expr;

expr: assignment |
      yield |
      arg;

assignment_oper: <EQ> | <PLUS_EQUAL> | <MINUS_EQUAL> | <DIV_EQUAL> | <OR_EQUAL>;

assignment: send assignment_oper expr;

yield: YIELD [LPAREN] args? [RPAREN] |
       YIELD args?;

arg: ternary;

ternary: range QUESTION ternary COLON ternary | <range>;

range_oper: <DOTDOT> | <DOTDOTDOT>;
match_oper: <EQUAL_TILDE> | <EXCLAMATION_TILDE>;
bool_oper: <OR> | <AND>;
cmp_oper: <EQEQ> | <EQEQEQ> | <NE> | <LT> | <LE> | <GT> | <GE> | <LEGT>;
shift_oper: <LSHIFT>;
add_oper: <PLUS> | <MINUS>;
mul_oper: <DIV> | <MODULO> | <MUL>;
unary_oper: <UNARY_MINUS> | <EXCLAMATION>;

range: match range_oper range | <match>;
match: bool match_oper match | <bool>;
bool: comparison bool_oper bool | <comparison>;
comparison: or cmp_oper comparison | <or>;
or: and PIPE or | <and>;
and: shiftive AMP and | <shiftive>;
shiftive: additive shift_oper shiftive | <additive>;
additive: multitive add_oper additive | <multitive>;
multitive: unary_op mul_oper multitive | <unary_op>;

unary_op: unary_oper arg | <send>;

send: <do_block> |
      real_send |
      <primary>;

do_block: real_send DO block_args? line* statement? [LINE_END]? END;

block_args: [PIPE] arglist? [PIPE] |
            [OR];

real_send: primary trailers |
           global_block |
           IDENTIFIER send_args block? |
           IDENTIFIER [LPAREN] send_args? [RPAREN] block?;

global_block: IDENTIFIER block;

block: [LBRACE] block_args? line* statement? [LINE_END]? [RBRACE];

trailers: trailer >trailers< | trailer;

trailer: subscript | attribute | constant;
attribute: [DOT] operation [LPAREN] send_args? [RPAREN] block? |
           [DOT] operation block |
           [DOT] operation send_args?;
subscript: [LSUBSCRIPT] arg [RBRACKET];
constant: COLONCOLON IDENTIFIER;

primary: LPAREN expr RPAREN |
         LBRACKET args? RBRACKET |
         LBRACE assocs? RBRACE |
         IF if elsifs? else? [END] |
         UNLESS expr then line* statement? [LINE_END]? END |
         WHILE expr do line* statement? [LINE_END]? END |
         UNTIL expr do line* statement? [LINE_END]? END |
         DEF function_name argdecl line* statement? [LINE_END]? END |
         CLASS LSHIFT arg [LINE_END] line* statement? [LINE_END]? END |
         CLASS IDENTIFIER (LT arg)? [LINE_END] line* statement? [LINE_END]? END |
         MODULE IDENTIFIER line* statement? [LINE_END]? END |
         BEGIN line* statement? [LINE_END]? rescue* ensure? END |
         CASE expr [LINE_END] whens else? END |
         varname |
         literal;

if: expr then line* statement? [LINE_END]?;

then: [LINE_END] |
      THEN |
      [LINE_END] THEN;

do: [LINE_END] |
    DO |
    [LINE_END] DO;

elsifs: elsif >elsifs< | elsif;

elsif: ELSIF expr then line* statement? [LINE_END]?;

else: ELSE line* statement? [LINE_END]?;

rescue: RESCUE varname? (ARROW IDENTIFIER)? line* statement? [LINE_END]?;

ensure: ENSURE line* statement? [LINE_END]?;

whens: when >whens< | when;

when: WHEN expr then line* statement? [LINE_END]?;

function_name: varname [DOT] IDENTIFIER |
               IDENTIFIER;

argdecl: [LPAREN] arglist? [RPAREN] |
         arglist? [LINE_END];

arglist: argdef [COMMA] >arglist< | argdef;

argdef: IDENTIFIER [EQ] arg |
        UNARY_STAR IDENTIFIER |
        AMP IDENTIFIER |
        IDENTIFIER;

operation: IDENTIFIER;

send_args: args ([COMMA] block_arg)? |
           block_arg;

args: argument [COMMA] >args< | argument;

argument: <arg> | <splat>;

splat: [UNARY_STAR] arg;

block_arg: [AMP] arg;

assocs: assoc [COMMA] >assocs< | assoc;

assoc: arg ARROW arg;

varname: IDENTIFIER |
         AT_SIGN IDENTIFIER |
         GLOBAL;

literal: NUMBER | SYMBOL | STRING | REGEXP;
