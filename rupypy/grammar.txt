# compstmt: line* statement? [LINE_END]?;
# unfortunately you need to inline this anywhere you want it because ebnf parse
# doesn't support epsilon productions.

main: line* statement? [LINE_END]? [EOF];

# XXX: LINE_END includes ';' which isn't valid for here, split LINE_END into
# two tokens and then have a non-terminal here for their union.
array_trailer: LINE_END |
               COMMA;

line: statement? [LINE_END];

# operator expressions, ordered by precedence
# Operator     		Description
# [ ] [ ]=		Element reference, element set
# **			Exponentiation
# ! ~ + -		Not, complement, unary plus and minus
# * / %			Multiply, divide, and modulo
# + -          	      	Plus and minus
# >> <<		      	Right and left shift
# &		      	Bitwise `and'
# ^ |		      	Bitwise exclusive `or' and regular `or'
# <= < > >=	      	Comparison operators
# <=> == === != =~ !~ 	Equality and pattern match operators
# &&	     	   	Logical `and'
# ||			Logical `or'
# .. ...		Range (inclusive and exclusive)
# ? :			Ternary if-then-else
# = %= { /= -= += |= &= >>= <<= *= &&= ||= **=	Assignment
# defined?	     	Check if symbol defined
# not			`literal_not`
# or and		`literal_bool`
# if unless while until	`inline_*`
# begin/end	  	Block expression

statement: inline_if |
           inline_unless |
           inline_until |
           inline_while |
           inline_rescue |
           <real_statement>;

inline_if: real_statement IF_INLINE expr;

inline_unless: real_statement UNLESS_INLINE expr;

inline_until: real_statement UNTIL_INLINE expr;

inline_while: real_statement WHILE_INLINE expr;

inline_rescue: real_statement RESCUE_INLINE expr;

real_statement: return_expr | expr;

return_expr: RETURN exprs?;
exprs: expr [COMMA] >exprs< | expr;

expr: <literal_bool>;

literal_bool: contained_expr literal_bool_oper literal_bool | <contained_expr>;
literal_bool_oper: <OR_LITERAL> | <AND_LITERAL>;

contained_expr: literal_not | assignment | yield | arg;
literal_not: NOT_LITERAL contained_expr;

assignment_oper: <EQ> | <PLUS_EQUAL> | <MINUS_EQUAL> | <MUL_EQUAL> |
                 <DIV_EQUAL> | <MODULO_EQUAL> | <OR_EQUAL> | <AND_EQUAL>;
assignment: assign_target assignment_oper assign_rhs;
assign_target: send [COMMA] >assign_target< | send | splat;
assign_rhs: expr [COMMA] >assign_rhs< | expr | splat;

yield: YIELD [LPAREN] args? [RPAREN] |
       YIELD args?;

arg: ternary;

ternary: range QUESTION ternary COLON ternary | <range>;

range_oper: <DOTDOT> | <DOTDOTDOT>;
match_oper: <EQUAL_TILDE> | <EXCLAMATION_TILDE>;
bool_oper: <OR> | <AND> | <CARET>;
cmp_oper: <EQEQ> | <EQEQEQ> | <NE> | <LT> | <LE> | <GT> | <GE> | <LEGT>;
shift_oper: <LSHIFT> | <RSHIFT>;
add_oper: <PLUS> | <MINUS>;
mul_oper: <DIV> | <MODULO> | <MUL>;
unary_oper: <UNARY_MINUS> | <TILDE> | <EXCLAMATION>;

range: match range_oper range | <match>;
match: bool match_oper match | <bool>;
bool: comparison bool_oper bool | <comparison>;
comparison: or cmp_oper comparison | <or>;
or: and PIPE or | <and>;
and: shiftive AMP and | <shiftive>;
shiftive: additive shift_oper shiftive | <additive>;
additive: multitive add_oper additive | <multitive>;
multitive: unary_op mul_oper multitive | <unary_op>;

unary_op: unary_oper expr | <pow>;

pow: send POW pow | <send>;

send: <do_block> |
      real_send |
      <primary>;

do_block: real_send DO block_args? line* statement? [LINE_END]? END;

block_args: [PIPE] arglist? [PIPE] |
            [OR];

real_send: primary trailers |
           global_paren_send trailers |
           ambigious_binop |
           global_send;

global_send: IDENTIFIER block |
             global_paren_send |
             IDENTIFIER send_args;

global_paren_send: IDENTIFIER [LPAREN] send_args? [RPAREN] block?;

block: [LBRACE] block_args? line* statement? [LINE_END]? [RBRACE];

trailers: trailer >trailers< | trailer;

trailer: subscript | attribute | constant;
attribute: [DOT] operation [LPAREN] send_args? [RPAREN] block? |
           [DOT] operation block |
           [DOT] operation send_args?;
subscript: LSUBSCRIPT args? [RBRACKET];
constant: COLONCOLON IDENTIFIER;

ambigious_binop: IDENTIFIER UNARY_MINUS arg;

primary: LPAREN expr RPAREN |
         LBRACKET array |
         LBRACE hash |
         IF if elsifs? else? [END] |
         UNLESS if else? [END] |
         WHILE expr do line* statement? [LINE_END]? END |
         UNTIL expr do line* statement? [LINE_END]? END |
         DEF function_name argdecl line* statement? [LINE_END]? rescue* ensure? [END] |
         CLASS LSHIFT arg [LINE_END] line* statement? [LINE_END]? END |
         CLASS IDENTIFIER (LT arg)? [LINE_END] line* statement? [LINE_END]? END |
         MODULE IDENTIFIER line* statement? [LINE_END]? END |
         BEGIN line* statement? [LINE_END]? rescue* else? ensure? END |
         CASE expr [LINE_END] whens else? END |
         varname |
         literal;

array: [RBRACKET] |
       args [array_trailer]? [RBRACKET];

hash: [RBRACE] |
      assocs [array_trailer]? [RBRACE];

if: expr then line* statement? [LINE_END]?;

then: [LINE_END] |
      THEN |
      [LINE_END] THEN;

do: [LINE_END] |
    DO |
    [LINE_END] DO;

elsifs: elsif >elsifs< | elsif;

elsif: ELSIF expr then line* statement? [LINE_END]?;

else: ELSE line* statement? [LINE_END]?;

rescue: RESCUE varname? (ARROW varname)? line* statement? [LINE_END]?;

ensure: ENSURE line* statement? [LINE_END]?;

whens: when >whens< | when;

when: WHEN exprs then line* statement? [LINE_END]?;

function_name: varname [DOT] method_name |
               method_name;

method_name: <IDENTIFIER> | <LEGT> | <EQEQEQ> | <LT> | <GT> | <GE> | <LE> |
             <EQEQ> | <LSHIFT> | <EQUAL_TILDE>;

argdecl: [LPAREN] arglist? [RPAREN] |
         arglist? [LINE_END];

arglist: argdef [COMMA] >arglist< | argdef;

argdef: IDENTIFIER [EQ] arg |
        UNARY_STAR IDENTIFIER |
        AMP IDENTIFIER |
        IDENTIFIER;

operation: IDENTIFIER;

send_args: args ([COMMA] block_arg)? |
           block_arg;

args: argument [COMMA] >args< | argument;

argument: <arg> | <splat>;

splat: [UNARY_STAR] arg;

block_arg: [AMP] arg;

assocs: assoc [COMMA] >assocs< | assoc;

assoc: contained_expr ARROW contained_expr;

varname: IDENTIFIER | CLASS_VAR | INSTANCE_VAR | GLOBAL;

literal: NUMBER | symbol | SSTRING | qwords | regexp | shellout | string;

symbol: [SYMBOL_BEGIN] symbol_contents;

symbol_contents: <varname> | <string>;

qwords: [QWORDS_BEGIN] strings [QWORDS_END];

regexp: [REGEXP_BEGIN] string [REGEXP_END];

shellout: [SHELL_BEGIN] string [SHELL_END];

strings: string >strings< | string;

string: [STRING_BEGIN] string_contents* [STRING_END];

string_contents: <STRING_VALUE> |
                 [DSTRING_START] <statement> [DSTRING_END];

